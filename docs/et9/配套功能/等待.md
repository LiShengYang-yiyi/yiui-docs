# 等待

**URL**: https://ai.feishu.cn/wiki/QbUPwx0eUiPPXtkA18qcU8I4nSo

**Parent**: 配套功能

**Depth**: 3

---
等待
输入“/”快速插入内容
等待
亦亦
通用的UI等待
实际项目中发现有大量的需求
逻辑需要等待某个UI进行系列操作后继续执行
如:
幸存者类游戏 弹出来的 三选一UI界面  等待玩家选择后 继续执行某个操作
弱引导 打开某个UI玩家执行自定义操作后 关闭UI 继续执行XX
UI上会有非常多这种需求
以前要么用回调 要么用通知 等方式实现
现在也可以使用异步方式
常规写法
代码块
C#
//1 需要等待的地方
var objWait = xx.GetComponent&lt;ObjectWait&gt;();
await objWait.Wait&lt;Event_WaitXxxxx&gt;();
//2 其他地方抛出等待完成
var objWait = xx.GetComponent&lt;ObjectWait&gt;();
objWait.Notify(new Event_WaitXxxxx());
功能:
ETCancellationToken 可提前取消等待
int timeout 超时
notify 不光是完成 还可传递数据
var result = await objWait.Wait&lt;Event_WaitXxxxx&gt;();
result.XX
需要提前定义Event_WaitXxxxx
需求
不想提前定义xx
因为每次还要定义这个很麻烦
因为没有提前定义 所以就没有了
数据传递功能
打开某个UI时  就开始等待这个UI关闭/摧毁 然后等待完成 继续其他流程
超时
不需要超时功能
因为UI打开了就是打开了只能等他关闭
不能要求某个UI必须多少秒关闭  如果有请用其他方式实现
取消
不需要取消功能
也是一样的
如果打开UI失败者判定等待完成
综上所述
不能直接用ObjectWait 所以仿照写一个类似的UI等待用
HashWait
具体看源码
本质上去掉了 需要提前定义Event_WaitXxxxx