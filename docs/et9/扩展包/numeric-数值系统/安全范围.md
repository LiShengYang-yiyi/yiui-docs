# 安全范围

安全范围 输入“/”快速插入内容 
# 安全范围

 
就算溢出了也没用只是知道溢出报错了而已 
 
 
 
 在不使用 checked 的情况下，要确保 long 类型的运算不会溢出，需严格限制输入值的范围。以下是算法步骤的 安全范围分析 和 具体约束条件 ： 
 安全范围约束（假设 IntRate = 10000 ）
 
 1. 输入参数范围 
 所有输入参数（ bas, add, pct, finalAdd, finalPct, resultAdd ）必须满足以下条件： 
 2. 分步骤安全范围 
 步骤1： valueBasAdd = bas + add 
 ◦ 溢出条件 ： bas + add > long.MaxValue 或 bas + add < long.MinValue 
 ◦ 安全范围 ： 
 ◦ plaintext 
 代码块 
 bas ∈ [long.MinValue + add, long.MaxValue - add] 
 add ∈ [long.MinValue + bas, long.MaxValue - bas] 
 ▪ 示例：若 bas = 1e18 ，则 add 必须满足 add ≤ long.MaxValue - 1e18 。 
 步骤2： valueAfterPct = valueBasAdd * (IntRate + pct) / IntRate 
 ◦ 溢出条件 ： valueBasAdd * (IntRate + pct) 超过 long 范围。 
 ◦ 安全范围 ： 
 ◦ plaintext 
 代码块 
 |valueBasAdd| ≤ long.MaxValue / (IntRate + pct) 
 由于 pct ∈ [0, IntRate]，最坏情况为 pct = IntRate → 分母为 2 * IntRate： 
 |valueBasAdd| ≤ long.MaxValue / (2 * IntRate) 
 ▪ 示例（ IntRate = 10000 ）： 
 ▪ plaintext 
 代码块 
 |valueBasAdd| ≤ 9,223,372,036,854,775,807 / 20,000 ≈ 4.6e14 
 即 bas + add 的绝对值必须 ≤ 4.6e14 
 步骤3： valueAfterFinalAdd = valueAfterPct + finalAdd 
 ◦ 溢出条件 ：同步骤1。 
 ◦ 安全范围 ： 
 ◦ plaintext 
 代码块 
 finalAdd ∈ [long.MinValue - valueAfterPct, long.MaxValue - valueAfterPct] 
 步骤4： valueAfterFinalPct = valueAfterFinalAdd * (IntRate + finalPct) / IntRate 
 ◦ 溢出条件 ：同步骤2。 
 ◦ 安全范围 ： 
 ◦ plaintext 
 代码块 
 |valueAfterFinalAdd| ≤ long.MaxValue / (IntRate + finalPct) 
 最坏情况：finalPct = IntRate → |valueAfterFinalAdd| ≤ long.MaxValue / (2 * IntRate) ≈ 4.6e14 
 步骤5： finalResult = valueAfterFinalPct + resultAdd 
 ◦ 溢出条件 ：同步骤1。 
 ◦ 安全范围 ： 
 ◦ plaintext